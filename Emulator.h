#pragma once
#include <cstdint>
#include "vk_init.h"
#include "imgui.h"
#include "imgui_memory_editor.h"
#include "imfilebrowser.h"

#include <set>

#define MEM_SIZE 0x10000

#define get_screen_pos(x, y) (uint8_t)((y) % 0x40)*128 + (uint8_t)((x) % 0x80)
#define double_upper_nibble(data) ((data) & 0x80) | (((data) >> 1) & 0x60) | (((data) >> 2) & 0x18) | (((data) >> 3) & 0x06) | (((data) >> 4) & 0x01)
const uint8_t font_data[] = {
    0xF0, 0x90, 0x90, 0x90, 0xF0,
    0x20, 0x60, 0x20, 0x20, 0x70,
    0xF0, 0x10, 0xF0, 0x80, 0xF0,
    0xF0, 0x10, 0xF0, 0x10, 0xF0,
    0x90, 0x90, 0xF0, 0x10, 0x10,
    0xF0, 0x80, 0xF0, 0x10, 0xF0,
    0xF0, 0x80, 0xF0, 0x90, 0xF0,
    0xF0, 0x10, 0x20, 0x40, 0x40,
    0xF0, 0x90, 0xF0, 0x90, 0xF0,
    0xF0, 0x90, 0xF0, 0x10, 0xF0,
    0xF0, 0x90, 0xF0, 0x90, 0x90,
    0xE0, 0x90, 0xE0, 0x90, 0xE0,
    0xF0, 0x80, 0x80, 0x80, 0xF0,
    0xE0, 0x90, 0x90, 0x90, 0xE0,
    0xF0, 0x80, 0xF0, 0x80, 0xF0,
    0xF0, 0x80, 0xF0, 0x80, 0x80,
    0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0x7E,
    0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x7E, 0xFF, 0xC3, 0xC7, 0x0E, 0x1C, 0x38, 0x70, 0xFF, 0xFF,
    0x7E, 0xFF, 0xC3, 0x07, 0x1E, 0x1E, 0x07, 0xC3, 0xFF, 0x7E,
    0xC6, 0xC6, 0xC6, 0xC6, 0xFF, 0xFF, 0x06, 0x06, 0x06, 0x06,
    0xFF, 0xFF, 0xC0, 0xC0, 0xFE, 0x7F, 0x03, 0x03, 0xFF, 0xFE,
    0x7E, 0xFF, 0xC3, 0xC0, 0xFE, 0xFF, 0xC3, 0xC3, 0xFF, 0x7E,
    0xFF, 0xFF, 0x07, 0x06, 0x0C, 0x0C, 0x18, 0x18, 0x30, 0x30,
    0x7E, 0xFF, 0xC3, 0xC3, 0x7E, 0xFF, 0xC3, 0xC3, 0xFF, 0x7E,
    0x7E, 0xFF, 0xC3, 0xC3, 0xFF, 0x7F, 0x03, 0xC3, 0xFF, 0x7E
};

const ImGuiKey key_map[] = {
    ImGuiKey_X,
    ImGuiKey_1,
    ImGuiKey_2,
    ImGuiKey_3,
    ImGuiKey_Q,
    ImGuiKey_W,
    ImGuiKey_E,
    ImGuiKey_A,
    ImGuiKey_S,
    ImGuiKey_D,
    ImGuiKey_Z,
    ImGuiKey_C,
    ImGuiKey_4,
    ImGuiKey_R,
    ImGuiKey_F,
    ImGuiKey_V
};

struct Instruction {
    uint16_t data;
    uint16_t get_all() { return (data << 8) | (data >> 8); }
    uint8_t get_high() { return data & 0x00FF; }
    uint8_t get_low() { return data >> 8; }
    uint8_t get_high_high() { return (data >> 4) & 0x000F; }
    uint8_t get_high_low() { return (data >> 0) & 0x000F; }
    uint8_t get_low_high() { return (data >> 12) & 0x000F; }
    uint8_t get_low_low() { return (data >> 8) & 0x000F; }
    std::string toString() {
        char hex_string[10];
        sprintf_s(hex_string, "%02x %02x", get_high(), get_low());
        return std::string(hex_string);
    }
};

class Emulator
{
private:
    bool paused = false;
    bool step_once = false;

    // Display variables
    Color* display;
    uint8_t display_bitmap[2][16 * 64];
    Color palate[4] = {
        { 0x00, 0x00, 0x00, 0xFF },  // Black
        { 0xFF, 0xFF, 0xFF, 0xFE },  // White
        { 0x55, 0x55, 0x55, 0xFD },  // Dark Gray
        { 0xAA, 0xAA, 0xAA, 0xFC }   // Light Gray
    };
    float color_select[4][3];
    uint8_t color_plane{ 1 };

    bool high_resolution{ false };
    bool palate_select{ false };
    // Timing
    float frequency{ 2 };
    double time = 0;
    uint32_t counter = 0;
    uint8_t delay_timer = 0;
    uint8_t sound_timer = 0;
    // Memory
    uint8_t* memory;
    uint16_t stack[0x1000];
    uint8_t register_file[16];
    uint8_t rpl_file[16];
    uint16_t program_counter = 0x0200;
    uint8_t stack_pointer = 0x00;
    uint16_t i_register = 0x0000;
    // IO
    bool keys[16];
    bool waiting_on_release{ false };
    MemoryEditor editor;
    ImGui::FileBrowser file_dialog{ImGuiFileBrowserFlags_NoModal};

    void get_instruction(Instruction& in);
    void sync_display();
    void draw_array_to_display(uint8_t* byte_array, uint8_t x, uint8_t y, int width, int height, uint8_t bitmap_index);
    void skip_next_instruction();
    void execute(Instruction& in);
    void tick_timers();
    void step();
    void load_file(const char* filename);
    void set_keys();
    void clear_screen();
public:
    Emulator(Color display[]);
    ~Emulator();
    void tick();
    void render();
};